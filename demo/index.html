<!doctype html>

<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>

    <title>Burrow Renderer - Demo</title>

    <style>
      html, body {
        height: 100%;
        margin: 0;
      }

      body {
        height: 100%;
        background-color: #222222;
      }

      canvas {
        position: absolute;
        z-index: 0;
        height: 100%;
        width: 100%;
        inset: 0;
        margin: 0;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <canvas></canvas>
    <script type="module">
      import 'https://cdn.jsdelivr.net/npm/tweakpane@3.1.0/dist/tweakpane.min.js';

      import { DeferredRenderer, DebugViewType } from '../dist/renderer/deferred-renderer.js';
      import { GltfLoader } from '../dist/loader/gltf.js';
      import { OrbitCamera } from '../dist/orbit-camera.js';
      import { CubeGeometryDesc } from './cube.js';
      import { Mat4 } from '../third-party/gl-matrix/dist/src/index.js';

      const LOCAL_MODELS = false;
      let GltfModels;
      if (LOCAL_MODELS) {
        const GltfRootDir = './media/models';
        GltfModels = {
          //antique_camera: `${GltfRootDir}/AntiqueCamera/glTF/AntiqueCamera.gltf`,
          boom_box: `${GltfRootDir}/BoomBox/glTF-Draco/BoomBox.gltf`,
          //corset: `${GltfRootDir}/Corset/glTF-Binary/Corset.glb`,
          damaged_helmet: `${GltfRootDir}/DamagedHelmet/glTF-Binary/DamagedHelmet.glb`,
          //flight_helmet: `${GltfRootDir}/FlightHelmet/glTF/FlightHelmet.gltf`,
          //lantern: `${GltfRootDir}/Lantern/glTF/Lantern.gltf`,
          //shoe: `${GltfRootDir}/MaterialsVariantsShoe/glTF/MaterialsVariantsShoe.gltf`,
          metal_rough_spheres: `${GltfRootDir}/MetalRoughSpheres/glTF/MetalRoughSpheres.gltf`,
          scifi_helmet: `${GltfRootDir}/SciFiHelmet/glTF/SciFiHelmet.gltf`,
          //suzanne: `${GltfRootDir}/Suzanne/glTF/Suzanne.gltf`,
          water_bottle: `${GltfRootDir}/WaterBottle/glTF-Binary/WaterBottle.glb`,
        };
      } else {
        const GltfRootDir = '../../glTF-Sample-Models/2.0';
        GltfModels = {
          antique_camera: `${GltfRootDir}/AntiqueCamera/glTF/AntiqueCamera.gltf`,
          boom_box: `${GltfRootDir}/BoomBox/glTF-Draco/BoomBox.gltf`,
          corset: `${GltfRootDir}/Corset/glTF-Binary/Corset.glb`,
          damaged_helmet: `${GltfRootDir}/DamagedHelmet/glTF-Binary/DamagedHelmet.glb`,
          flight_helmet: `${GltfRootDir}/FlightHelmet/glTF/FlightHelmet.gltf`,
          lantern: `${GltfRootDir}/Lantern/glTF/Lantern.gltf`,
          shoe: `${GltfRootDir}/MaterialsVariantsShoe/glTF/MaterialsVariantsShoe.gltf`,
          metal_rough_spheres: `${GltfRootDir}/MetalRoughSpheres/glTF/MetalRoughSpheres.gltf`,
          mosquito_in_amber: `${GltfRootDir}/MosquitoInAmber/glTF-Binary/MosquitoInAmber.glb`,
          scifi_helmet: `${GltfRootDir}/SciFiHelmet/glTF/SciFiHelmet.gltf`,
          suzanne: `${GltfRootDir}/Suzanne/glTF/Suzanne.gltf`,
          toy_car: `${GltfRootDir}/ToyCar/glTF-Binary/ToyCar.glb`,
          unlit_test: `${GltfRootDir}/UnlitTest/glTF/UnlitTest.gltf`,
          water_bottle: `${GltfRootDir}/WaterBottle/glTF-Binary/WaterBottle.glb`,
        };
      }

      let modelPath = GltfModels.scifi_helmet;

      const EnvMaps = {
        none: null,
        lightroom: './media/environments/lightroom_14b_ibl.ktx',
        quattro_canti: './media/environments/quattro_canti_ibl.ktx',
        industrial_pipe_and_valve: './media/environments/industrial_pipe_and_valve_ibl.ktx',
        symmetrical_garden: './media/environments/symmetrical_garden_1k_ibl.ktx',
      };
      let envPath = EnvMaps.quattro_canti;

      // Features to enable on the device if available.
      const preferredFeatures = ['texture-compression-bc', 'texture-compression-etc2'];

      const adapter = await navigator.gpu.requestAdapter();

      const requiredFeatures = [];
      for (const feature of preferredFeatures) {
        if (adapter.features.has(feature)) { requiredFeatures.push(feature); }
      }

      const device = await adapter.requestDevice({ requiredFeatures });

      const canvas = document.querySelector('canvas');
      const context = canvas.getContext('webgpu');
      context.configure({
        device,
        format: navigator.gpu.getPreferredCanvasFormat(),
        alphaMode: 'premultiplied',
      });

      const renderer = new DeferredRenderer(device);
      const gltfLoader = new GltfLoader(renderer);
      const textureLoader = gltfLoader.textureLoader;

      const cubeGeometry = renderer.createGeometry(CubeGeometryDesc);

      let scene = {
        meshes: [{
          transform: new Mat4(),
          geometry: cubeGeometry,
        }],
      };

      function loadModel(path) {
        modelPath = path;
        gltfLoader.loadFromUrl(path).then((gltfScene) => {
          scene = gltfScene;
        });
      }
      loadModel(modelPath);

      function loadEnv(path) {
        envPath = path;
        if (path) {
          gltfLoader.textureLoader.fromUrl(path).then((texture) => {
            renderer.environment = texture;
          });
        } else {
          renderer.environment = null;
        }
      }
      loadEnv(envPath);

      const camera = new OrbitCamera(canvas);
      camera.distance = 3;

      // Debug panel
      const debugPane = new Tweakpane.Pane({
        title: 'Debug',
        expanded: false,
      });

      debugPane.addBlade({
        label: 'model',
        view: 'list',
        options: GltfModels,
        value: modelPath,
      }).on('change', (ev) => {
        loadModel(ev.value);
      });

      debugPane.addBlade({
        label: 'environment',
        view: 'list',
        options: EnvMaps,
        value: envPath,
      }).on('change', (ev) => {
        loadEnv(ev.value);
      });

      debugPane.addInput(renderer, 'enableBloom');

      debugPane.addBlade({
        label: 'debugView',
        view: 'list',
        options: DebugViewType,
        value: renderer.debugView,
      }).on('change', (ev) => {
        renderer.debugView = ev.value;
      });

      debugPane.addButton({
        label: 'Cache',
        title: 'Clear',
      }).on('click', (ev) => {
        console.log('Clearing Cache');
        gltfLoader.clearCache();
      });

      const pointLightColors = [
        { color: [1.0, 1.0, 1.0], intensity: 3, range: 5 },
        { color: [1.0, 0.3, 0.3], intensity: 1, range: 5 },
        { color: [0.3, 1.0, 0.3], intensity: 2, range: 5 },
        { color: [0.3, 0.3, 1.0], intensity: 1, range: 5 },
        { color: [1.0, 1.0, 0.3], intensity: 2, range: 5 },
        { color: [0.3, 1.0, 1.0], intensity: 2, range: 5 },
      ];

      const lightState = {
        pointLightCount: pointLightColors.length,
        pointLights: [],
        animateLights: true,
      };

      function updatePointLights(timestamp) {
        if (lightState.animateLights || lightState.pointLights.length == 0) {
          lightState.pointLights = [];
          for (let i = 0; i < lightState.pointLightCount; ++i) {
            const r = (i / lightState.pointLightCount) * Math.PI * 2 + (timestamp/1000);
            lightState.pointLights.push({
              position: [
                Math.sin(r) * 2.5,
                Math.sin(timestamp / 1000 + (i / lightState.pointLightCount)) * 1.5,
                Math.cos(r) * 2.5,
              ],
              ...pointLightColors[i % pointLightColors.length]
            });
          }
        }
      }

      const lightsFolder = debugPane.addFolder({
        title: 'Lights',
        expanded: true,
      });

      lightsFolder.addInput(renderer.tonemapRenderer, 'exposure', {
        step: 0.1,
        min: 0.1,
        max: 2.5,
      });

      lightsFolder.addInput(lightState, 'pointLightCount', {
        step: 1,
        min: 0,
        max: pointLightColors.length,
      });
      lightsFolder.addInput(lightState, 'animateLights');

      const stats = {
        fps: 0,
        frameMs: 0
      };

      const statsFolder = debugPane.addFolder({
        title: 'Stats',
        expanded: true,
      });
      statsFolder.addMonitor(stats, 'fps', {
        view: 'graph',
        min: 0,
        max: 90
      });
      statsFolder.addMonitor(stats, 'frameMs', {
        view: 'graph',
        min: 0,
        max: 2
      });

      // Event handlers
      function onResize() {
        const dpr = Math.min(devicePixelRatio, 2);
        canvas.width = canvas.offsetWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        renderer.resize(canvas.width, canvas.height);
      }
      onResize();
      window.addEventListener('resize', onResize);

      // Frame loop
      let frameCount = 0;
      let lastFrameTime = performance.now();
      function onFrame(timestamp) {
        requestAnimationFrame(onFrame);
        const frameStart = performance.now();
        frameCount++;

        updatePointLights(timestamp);
        scene.pointLights = lightState.pointLights;

        const outputTexture = context.getCurrentTexture();

        renderer.render(outputTexture, camera, scene);

        const frameEnd = performance.now();
        stats.frameMs = frameEnd - frameStart;
        if (frameEnd - lastFrameTime > 1000) {
          lastFrameTime = frameEnd;
          stats.fps = frameCount;
          frameCount = 0;
        }
      }
      requestAnimationFrame(onFrame);
    </script>
  </body>
</html>