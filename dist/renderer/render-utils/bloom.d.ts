/// <reference types="dist" />
export declare const bloomShader = "\n  @group(0) @binding(0) var sourceTexture: texture_2d<f32>;\n  @group(0) @binding(1) var sourceSampler: sampler;\n\n  @fragment\n  fn downsampleMain(@location(0) texcoord : vec2f) -> @location(0) vec4f {\n    let texelSize = (1.0 / vec2f(textureDimensions(sourceTexture)));\n    let x = texelSize.x;\n    let y = texelSize.y;\n\n    let a = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x - 2*x, texcoord.y + 2*y)).rgb;\n    let b = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x,       texcoord.y + 2*y)).rgb;\n    let c = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x + 2*x, texcoord.y + 2*y)).rgb;\n\n    let d = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x - 2*x, texcoord.y)).rgb;\n    let e = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x,       texcoord.y)).rgb;\n    let f = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x + 2*x, texcoord.y)).rgb;\n\n    let g = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x - 2*x, texcoord.y - 2*y)).rgb;\n    let h = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x,       texcoord.y - 2*y)).rgb;\n    let i = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x + 2*x, texcoord.y - 2*y)).rgb;\n\n    let j = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x - x, texcoord.y + y)).rgb;\n    let k = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x + x, texcoord.y + y)).rgb;\n    let l = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x - x, texcoord.y - y)).rgb;\n    let m = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x + x, texcoord.y - y)).rgb;\n\n    var downsample = e*0.125;\n    downsample += (a+c+g+i)*0.03125;\n    downsample += (b+d+f+h)*0.0625;\n    downsample += (j+k+l+m)*0.125;\n    return vec4f(downsample, 1);\n  }\n\n  const filterRadius = 0.005;\n\n  @fragment\n  fn upsampleMain(@location(0) texcoord : vec2f) -> @location(0) vec4f {\n    let x = filterRadius;\n    let y = filterRadius;\n\n    let a = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x - x, texcoord.y + y)).rgb;\n    let b = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x,     texcoord.y + y)).rgb;\n    let c = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x + x, texcoord.y + y)).rgb;\n\n    let d = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x - x, texcoord.y)).rgb;\n    let e = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x,     texcoord.y)).rgb;\n    let f = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x + x, texcoord.y)).rgb;\n\n    let g = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x - x, texcoord.y - y)).rgb;\n    let h = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x,     texcoord.y - y)).rgb;\n    let i = textureSample(sourceTexture, sourceSampler, vec2f(texcoord.x + x, texcoord.y - y)).rgb;\n\n    var upsample = e*4.0;\n    upsample += (b+d+f+h)*2.0;\n    upsample += (a+c+g+i);\n    upsample *= 1.0 / 16.0;\n    return vec4f(upsample, 1);\n  }\n";
export declare class BloomRenderer {
    device: GPUDevice;
    bindGroupLayout: GPUBindGroupLayout;
    bindGroups: GPUBindGroup[];
    downsamplePipeline: GPURenderPipeline;
    upsamplePipeline: GPURenderPipeline;
    sampler: GPUSampler;
    inputTextureView: GPUTextureView;
    intermediateTexture: GPUTexture;
    constructor(device: GPUDevice, format: GPUTextureFormat);
    updateInputTexture(texture: GPUTexture): void;
    render(encoder: GPUCommandEncoder): void;
}
